#!/usr/bin/sbcl --script
(require :asdf)
(asdf:load-system :uiop)
(defvar *verbose* nil)
(defvar *path* nil)

(defun find-files-containing (search-string dir)
  "Recursively grep for SEARCH-STRING in DIR.
Return a list of file names as strings."
  (let ((output-stream (make-string-output-stream)))
    (sb-ext::run-program "grep" (list "-rl" search-string dir)
			 :search t :output output-stream)
    (remove "" (uiop:split-string (get-output-stream-string output-stream) :separator '(#\NEWLINE))
	    :test #'equal)))

(defun find-yarn2nix-files (dir)
  "Find all the files generated by yarn2nix in DIR.
Look for files with the 'nix' extension containing the string
'offline_cache = linkfarm'."
  (loop
     for file in (find-files-containing "offline_cache = linkFarm" dir)
     for ext = (car (last (uiop:split-string file :separator '(#\.))))
     when (equal ext "nix") collect file))

(defun find-gemset-files (dir)
  "Find all the files generated by bundix in DIR.
Look for files with the 'nix' extension containing the string
'remotes = [\"https://rubygems.org\"]'."
  (find-files-containing "remotes = \\[\"https://rubygems.org\"\\]" dir))

(defun parse (file)
  (let ((output-stream (make-string-output-stream))
	(chars-to-remove '(#\, #\- #\[ #\])))
    (sb-ext::run-program "nix-parser" (list file)
			 :search t :output output-stream)
    (let ((node (read-from-string
		 (concatenate 'string
			      (loop for char across (get-output-stream-string output-stream)
				 unless (member char chars-to-remove)
				 collect char))))
	  (lines (read-all-lines file)))
      (copy-strings-into-tree node lines))))

(defun read-all-lines (file)
  (concatenate 'vector (with-open-file (stream file)
			 (loop for line = (read-line stream nil 'foo)
			    until (eq line 'foo)
			    collect line))))

(defun copy-strings-into-tree (node lines)
  "Replace the line and character position references in NODE with strings from LINES.
NODE is a parse tree and LINES the list of lines in the file that was
parsed to create NODE."
  (destructuring-bind (node-type beg-line beg-char end-line end-char . children) node
    (case node-type
      ((identifier string)
       (assert (= beg-line end-line))
       (list node-type (subseq (aref lines beg-line) beg-char end-char)))
      (indented_string
       (let ((strings (subseq lines beg-line (1+ end-line)))
	     (lastpos (- end-line beg-line)))
	 (setf (aref strings 0) (subseq (aref strings 0) beg-char))
	 (setf (aref strings lastpos) (subseq (aref strings lastpos) 0 end-char))
	 (cons node-type (concatenate 'list strings))))
      (t (cons node-type (mapcar #'(lambda (child) (copy-strings-into-tree child lines)) children))))))

(defun node-type (node)
  (car node))

(defun node-value (node)
  (assert (member (node-type node) '(identifier string indented-string)))
  (cadr node))

(defun node-children (node)
  (cdr node))

(defun bigger (indent)
  (concatenate 'string indent "  "))

(defun render (node &optional indent)
  "Print the parse tree NODE as Nix code, indented by INDENT."
  (unless indent
    (setq indent ""))
  (case (node-type node)
    (expression (render (nth 0 (node-children node)) indent))
    (function (concatenate 'string
			   (render (nth 0 (node-children node)) indent)
			   ": "
			   (render (nth 1 (node-children node)) indent)))
    (formals (format nil "{~{ ~A~^,~} }"
		     (mapcar (lambda (child) (render child indent))
			     (node-children node))))
    ((formal attrpath) (render (nth 0 (node-children node)) indent))
    (identifier (node-value node))
    ((rec_attrset attrset) (concatenate
			    'string
			    (format nil "~A{~%" (if (eq (node-type node) 'rec_attrset)
						    "rec " ""))
			    (format nil "~{~A;~%~}"
				    (mapcar (lambda (child) (render child (bigger indent)))
					    (node-children node)))
			    (format nil "~A}" indent)))
    (list (format nil "[~%~{~A~%~}~A]"
		  (mapcar (lambda (child)
			    (concatenate 'string (bigger indent) (render child (bigger indent))))
			  (node-children node))
		  indent))
    (let (let* ((children (node-children node))
		(bindings (butlast children))
		(expression (car (last children))))
	   (concatenate 'string
			(format nil "~%~Alet~%" indent)
			(format nil "~{~A;~%~}" (mapcar (lambda (binding)
							  (render binding (bigger indent)))
							bindings))
			(format nil "~Ain~%~A~A" indent (bigger indent)
				(render expression (bigger indent))))))
    (app (format nil "~A ~A"
		 (render (nth 0 (node-children node)) indent)
		 (render (nth 1 (node-children node)) indent)))
    (string (node-value node))
    (indented_string (format nil "~{~A~^~%~}" (node-children node)))
    (bind (format nil "~A~A = ~A"
		  indent
		  (render (nth 0 (node-children node)) indent)
		  (render (nth 1 (node-children node)) indent)))
    (interpolation "")
    (t (string (node-type node)))))

(defun binding-left-id (node)
  "Given a NODE of type `bind', return the left side identifier string."
  (assert (eq (node-type node) 'bind))
  (let ((left-child (nth 0 (node-children node))))
    (assert (eq (node-type left-child) 'attrpath))
    (let ((identifier (nth 0 (node-children left-child))))
      (assert (eq (node-type identifier) 'identifier))
      (node-value identifier))))

(defun get-binding-by-name (name attrset)
  "Given an attribute set ATTRSET containing bindings, return the one binding NAME."
  (assert (member (node-type attrset) '(rec_attrset attrset)))
  (catch 'result
    (dolist (binding (node-children attrset))
      (when (equal (binding-left-id binding) name)
	(throw 'result (nth 1 (node-children binding)))))))

(defun get-packages-list (expression)
  (let* ((function (nth 0 (node-children expression)))
	 (body (nth 1 (node-children function))))
    (get-binding-by-name "packages" body)))

(defun add-to-packages-by-sha1 (expression packages-by-sha1)
  (let ((packages-list (node-children (get-packages-list expression))))
    (dolist (package packages-list)
      (let ((path (get-binding-by-name "path" package)))
	(when (eq (node-type path) 'app)
	  (let* ((args (nth 1 (node-children path)))
		 (sha1 (node-value (get-binding-by-name "sha1" args)))
		 (value (gethash sha1 packages-by-sha1 0)))
	    (setf (gethash sha1 packages-by-sha1) (1+ value))))))))


(defun tally-yarn-definitions (yarnfiles)
  (let ((packages-by-sha1 (make-hash-table :test #'equal)))
    (dolist (yarnfile yarnfiles)
      (let ((tree (parse yarnfile)))
	(add-to-packages-by-sha1 tree packages-by-sha1)))
    (let ((sum 0))
      (maphash #'(lambda (key val)
		   (when (> val 1)
		     (setq sum (+ sum (1- val)))))
	       packages-by-sha1)
      (format t "Unique yarn package definitions: ~A~%" (hash-table-count packages-by-sha1))
      (format t "Duplicate yarn package definitions: ~A~%" sum)
      (format t "Total yarn package definitions: ~A~%" (+ sum (hash-table-count packages-by-sha1))))))

(defun add-to-gems-by-sha (attrset gems-by-sha)
  (let ((bindings (node-children attrset)))
    (dolist (binding bindings)
      (let* ((attrs (nth 1 (node-children binding)))
	     (source-binding (get-binding-by-name "source" attrs))
	     (sha (node-value (get-binding-by-name "sha256" source-binding)))
	     (value (gethash sha gems-by-sha 0))
	     )
	(setf (gethash sha gems-by-sha) (1+ value))))))


(defun tally-gemset-definitions (gemfiles)
  (let ((gems-by-sha (make-hash-table :test #'equal))
	(total-gems 0))
    (dolist (gemfile gemfiles)
      (let* ((tree (parse gemfile))
	     (attrset (nth 0 (node-children tree))))
	(setq total-gems (+ total-gems (length (node-children attrset))))
	(add-to-gems-by-sha attrset gems-by-sha)))
    (let ((sum 0))
      (maphash #'(lambda (key val)
		   (when (> val 1)
		     (setq sum (+ sum (1- val)))))
	       gems-by-sha)
      (format t "Unique gem definitions: ~A~%" (hash-table-count gems-by-sha))
      (format t "Duplicate gem definitions: ~A~%" sum)
      (format t "Total gem definitions: ~A~%" total-gems))))

;; Process arguments
(defun usage-message ()
  (format uiop:*stderr* "~A~%" "Usage: yarn-dedup NIXPKGS-DIR")
  (uiop:quit 1))

(unless (and (= (length sb-ext:*posix-argv*) 2))
  (usage-message))

(handler-case
    (setq *path* (uiop:unix-namestring
		  (merge-pathnames
		   (uiop:parse-unix-namestring (nth 1 sb-ext:*posix-argv*)))))
  (error (c)
    (usage-message)))

;; Do the work and print results
(let ((yarnfiles (find-yarn2nix-files *path*)))
  (format t "Found ~A Nix files produced by yarn2nix~%" (length yarnfiles))
  (tally-yarn-definitions yarnfiles))
(terpri)
(let ((gemfiles (find-gemset-files *path*)))
  (format t "Found ~A Nix files produced by bundix~%" (length gemfiles))
  (tally-gemset-definitions gemfiles))
